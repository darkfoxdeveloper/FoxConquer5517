// * ************************************************************
// * * START:                                         kernel.cs *
// * ************************************************************

// * ************************************************************
// *                      INFORMATIONS
// * ************************************************************
// * Kernel for the library. (Ex. Memory management)
// * kernel.cs
// * 
// * --
// *
// * Feel free to use this class in your projects, but don't
// * remove the header to keep the paternity of the class.
// * 
// * ************************************************************
// *                      CREDITS
// * ************************************************************
// * Originally created by CptSky (December 7th, 2011)
// * Copyright (C) 2011 CptSky
// *
// * ************************************************************

using System;
using System.Runtime.InteropServices;
using System.Text;

namespace CO2_CORE_DLL
{
    public unsafe class Kernel
    {
        #region Constants

        /// <summary>
        /// Standard size for a buffer. (4 KiB)
        /// 4 KiB represent the size of one disc block on most file system.
        /// /!\ Do not change the value to avoid I/O error. /!\
        /// </summary>
        public const Int32 MAX_BUFFER_SIZE = 4096;

        /// <summary>
        /// This macro expands to an integral constant expression whose value is the maximum value returned by
        /// the rand function.
        /// This value is library dependent, but is granted to be at least 32767.
        /// </summary>
        public const Int32 RAND_MAX = 0x7FFF;

        #endregion //Constants

        #region Variables

        private static UInt32 Seed = 1;

        #endregion //Variables

        #region Methods

        /// <summary>
        /// The pseudo-random number generator is initialized using the argument passed as seed.
        /// For every different seed value used in a call to srand, the pseudo-random number generator can
        /// be expected to generate a different succession of results in the subsequent calls to rand.
        /// Two different initializations with the same seed, instructs the pseudo-random generator to generate
        /// the same succession of results for the subsequent calls to rand in both cases.
        /// If seed is set to 1, the generator is reinitialized to its initial value and produces the same values
        /// as before any call to rand or srand.
        /// </summary>
        public static void srand(UInt32 seed)
        {
            Seed = seed;
        }

        /// <summary>
        /// Returns a pseudo-random integral number in the range 0 to RAND_MAX.
        /// This number is generated by an algorithm that returns a sequence of apparently non-related numbers
        /// each time it is called. This algorithm uses a seed to generate the series, which should be initialized
        /// to some distinctive value using srand.
        /// </summary>
        public static Int32 rand()
        {
            //This is the Microsoft's implementation since NT 2.0 and probably before.
            //Others OS have different implementation.
            return (Int32)(((Seed = Seed * 0x343FD + 0x269EC3) >> 16) & RAND_MAX);

            //The C standard's implementation. (RAND_MAX = 0x7FFF)
            //Seed = Seed * 1103515245 + 12345;
            //return (Int32)((UInt32)(Seed/65536) % 32768);
        }

        /// <summary>
        /// Allocates a block of size bytes of memory, returning a pointer to the beginning of the block.
        /// The content of the newly allocated block of memory is not initialized, remaining with indeterminate values.
        /// </summary>
        public static void* malloc(Int32 size)
        {
            void* ptr = Marshal.AllocHGlobal(size).ToPointer();
            return ptr;
        }

        /// <summary>
        /// Allocates a block of memory for an array of num elements, each of them size bytes long, and initializes
        /// all its bits to zero. The effective result is the allocation of an zero-initialized memory block of
        /// size bytes.
        /// </summary>
        public static void* calloc(Int32 size)
        {
            void* ptr = Marshal.AllocHGlobal(size).ToPointer();

            //This method is less effecient than the memset call, but is more portable.
            //The use of Int32 on both x86 and x64 is the best solution to upgrade the speed.
            //It may be due to the aligment of the data.

            //We consider that under Windows, any integer with all its bits to zero is equal to zero.
            //So we set the integer to zero. It is not the real implementation, but an optimized one
            //for any OS running the .net/mono framework.

            Int32 count = size / sizeof(Int32);
            for (Int32 i = 0; i < count; i++)
                *(((Int32*)ptr) + i) = 0;

            Int32 pos = size - (size % sizeof(Int32));
            for (Int32 i = 0; i < size % sizeof(Int32); i++)
                *(((Byte*)ptr) + pos + i) = 0;

            return ptr;
        }

        /// <summary>
        /// The size of the memory block pointed to by the ptr parameter is changed to the size bytes, expanding or
        /// reducing the amount of memory available in the block.
        /// The function may move the memory block to a new location, in which case the new location is returned.
        /// The content of the memory block is preserved up to the lesser of the new and old sizes,
        /// even if the block is moved. If the new size is larger, the value of the newly allocated portion is
        /// indeterminate.
        /// In case that ptr is NULL, the function behaves exactly as malloc, assigning a new block of size bytes and
        /// returning a pointer to the beginning of it.
        /// In case that the size is 0, the memory previously allocated in ptr is deallocated as if a call to free
        /// was made, and a NULL pointer is returned.
        /// </summary>
        public static void* realloc(void* ptr, Int32 size)
        {
            if (ptr != null)
                ptr = Marshal.ReAllocHGlobal((IntPtr)ptr, new IntPtr(size)).ToPointer();
            else
                ptr = Marshal.AllocHGlobal(size).ToPointer();
            return ptr;
        }

        /// <summary>
        /// A block of memory previously allocated using a call to malloc, calloc or realloc is deallocated, making
        /// it available again for further allocations.
        /// The pointer is not set to NULL. It has to be set manually.
        /// </summary>
        public static void free(void* ptr)
        {
            if (ptr != null)
                Marshal.FreeHGlobal((IntPtr)ptr);
        }

        /// <summary>
        /// Copies the values of num bytes from the location pointed by source directly to the memory block pointed
        /// by destination.
        /// The underlying type of the objects pointed by both the source and destination pointers are irrelevant for
        /// this function; The result is a binary copy of the data.
        /// The function does not check for any terminating null character in source - it always copies exactly numbytes.
        /// To avoid overflows, the size of the arrays pointed by both the destination and source parameters, shall be
        /// at least num bytes, and should not overlap (for overlapping memory blocks, memmove is a safer approach).
        /// </summary>
        public static void memcpy(void* dest, void* src, Int32 size)
        {
            //This method is less effecient than the memcpy call, but it is more portable.
            //The use of Int32 on both x86 and x64 is the best solution to upgrade the speed.
            //It may be due to the aligment of the data.

            Int32 count = size / sizeof(Int32);
            for (Int32 i = 0; i < count; i++)
                *(((Int32*)dest) + i) = *(((Int32*)src) + i);

            Int32 pos = size - (size % sizeof(Int32));
            for (Int32 i = 0; i < size % sizeof(Int32); i++)
                *(((Byte*)dest) + pos + i) = *(((Byte*)src) + pos + i);
        }

        /// <summary>
        /// Copies the values of num bytes from the location pointed by source directly to the memory block pointed
        /// by destination.
        /// The underlying type of the objects pointed by both the source and destination pointers are irrelevant for
        /// this function; The result is a binary copy of the data.
        /// The function does not check for any terminating null character in source - it always copies exactly num bytes.
        /// To avoid overflows, the size of the arrays pointed by both the destination and source parameters, shall be
        /// at least num bytes, and should not overlap (for overlapping memory blocks, memmove is a safer approach).
        /// </summary>
        public static void memcpy(Byte[] dest, void* src, Int32 size)
        {
            Marshal.Copy((IntPtr)src, dest, 0, size);
        }

        /// <summary>
        /// Copies the values of num bytes from the location pointed by source directly to the memory block pointed
        /// by destination.
        /// The underlying type of the objects pointed by both the source and destination pointers are irrelevant for
        /// this function; The result is a binary copy of the data.
        /// The function does not check for any terminating null character in source - it always copies exactly num bytes.
        /// To avoid overflows, the size of the arrays pointed by both the destination and source parameters, shall be
        /// at least num bytes, and should not overlap (for overlapping memory blocks, memmove is a safer approach).
        /// </summary>
        public static void memcpy(void* dest, Byte[] src, Int32 size)
        {
            Marshal.Copy(src, 0, (IntPtr)dest, size);
        }

        /// <summary>
        /// Sets the first num bytes of the block of memory pointed by ptr to the specified value.
        /// </summary>
        public static void* memset(void* ptr, Byte value, Int32 num)
        {
            for (Int32 i = 0; i < num; i++)
                *(((Byte*)ptr) + i) = value;
            return ptr;
        }

        /// <summary>
        /// Returns the length of str.
        /// The length of a C string is determined by the terminating null-character: A C string is as long as
        /// the amount of characters between the beginning of the string and the terminating null character.
        /// This should not be confused with the size of the array that holds the string.
        /// </summary>
        public static Int32 strlen(Byte* ptr)
        {
            for (Int32 i = 0; i < Int32.MaxValue; i++)
            {
                if (ptr[i] == '\0')
                    return i;
            }
            return Int32.MaxValue;
        }

        /// <summary>
        /// Convert a Windows-1252 null-terminated string in an UNICODE managed string object.
        /// This method is a custom one. It may has bugs.
        /// </summary>
        public static String cstring(Byte* src, Int32 size)
        {
            if (src == null)
                return null;

            StringBuilder Builder = new StringBuilder(size);
            for (Int32 i = 0; i < size; i++)
            {
                if (src[i] == '\0')
                    break;

                Builder.Append((Char)src[i]);
            }
            return Builder.ToString();
        }

        /// <summary>
        /// Convert a Windows-1252 null-terminated string in an UNICODE managed string object.
        /// This method is a custom one. It may has bugs.
        /// </summary>
        public static String cstring(Byte[] src)
        {
            if (src == null)
                return null;

            StringBuilder Builder = new StringBuilder(src.Length);
            for (Int32 i = 0; i < src.Length; i++)
            {
                if (src[i] == '\0')
                    break;
                Builder.Append((Char)src[i]);
            }
            return Builder.ToString();
        }

        /// <summary>
        /// Convert a Windows-1252 null-terminated string in an UNICODE managed string object.
        /// This method is a custom one. It may has bugs.
        /// </summary>
        public static String cstring(Byte[] src, Int32 pos, Int32 size)
        {
            if (src == null)
                return null;

            StringBuilder Builder = new StringBuilder(size);
            for (Int32 i = 0; i < size; i++)
            {
                if (src[i + pos] == '\0')
                    break;
                Builder.Append((Char)src[i + pos]);
            }
            return Builder.ToString();
        }

        public static void assert(Boolean expression)
        {
#if DEBUG
            if (!expression)
                throw new Exception("Assertion failed!");
#endif
        }

        #endregion //Methods
    }
}

// * ************************************************************
// * * END:                                           kernel.cs *
// * ************************************************************